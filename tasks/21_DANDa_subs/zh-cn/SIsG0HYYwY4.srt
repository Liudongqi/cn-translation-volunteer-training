1
00:00:00,135 --> 00:00:03,820
JSON 可几乎完美地映射到 Python 字典和数组上

2
00:00:03,820 --> 00:00:06,980
解析 XML 要复杂得多  

3
00:00:06,980 --> 00:00:09,290
这里有几个选项可选 我们来看些最常用的  

4
00:00:09,290 --> 00:00:11,900
我还推荐大家看看 

5
00:00:11,900 --> 00:00:14,190
Python XML 页面 看看你可以有哪些选择  

6
00:00:14,190 --> 00:00:18,500
我们首先来看看如何将 XML 解析为文档树

7
00:00:18,500 --> 00:00:22,430
它和 XML 的事件驱动解析 或者所谓的

8
00:00:22,430 --> 00:00:25,940
sax  解析之间的主要区别是   

9
00:00:25,940 --> 00:00:29,600
这里我们要把整个 XML 树 

10
00:00:29,600 --> 00:00:33,530
读入内存 我们要使用 xml.etree.ElementTree 模块   

11
00:00:33,530 --> 00:00:36,250
它是 Python 标准库的一部分 

12
00:00:36,250 --> 00:00:39,640
通过这个元素树 我们可以以几种方式了解析数据

13
00:00:39,640 --> 00:00:43,240
我们可以按照文件名进行解析

14
00:00:43,240 --> 00:00:44,790
也可以通过 ElementTree 模块的一种字符串方法  

15
00:00:44,790 --> 00:00:47,250
来使用它解析作为字符串值 

16
00:00:47,250 --> 00:00:51,080
储存在我们程序中的 XML  我们在考虑使用 ElementTree 解析 XML 时 

17
00:00:51,080 --> 00:00:54,670
使用面向文档的 XML 数据对我们来说是最明智的  

18
00:00:54,670 --> 00:00:58,500
因此我们回到研究论文的例子  

19
00:00:58,500 --> 00:01:02,280
来自 BioMed Central 的这个数据集

20
00:01:02,280 --> 00:01:04,920
既是用于文档编码的 XML 的很好例子    

21
00:01:04,920 --> 00:01:07,940
也是数据科学家 

22
00:01:07,940 --> 00:01:11,010
尤其是 TextMinded 内部人员在工作中最爱用到数据类型 

23
00:01:11,010 --> 00:01:13,710
从树上提取需要的数据时  

24
00:01:13,710 --> 00:01:17,570
我们最可能用到元素对象  

25
00:01:17,570 --> 00:01:20,150
元素让我们能循环遍历其子元素  

26
00:01:20,150 --> 00:01:23,830
例如 我们将这篇论文解析为

27
00:01:23,830 --> 00:01:26,220
一个树 从这个树上 我要找到  

28
00:01:26,220 --> 00:01:29,060
根元素 然后我们要循环遍历   

29
00:01:29,060 --> 00:01:31,340
该根元素的子元素  

30
00:01:31,340 --> 00:01:34,830
对于该情况 是使用标签属性来打印  

31
00:01:34,830 --> 00:01:38,640
每个子元素的标签名 

32
00:01:38,640 --> 00:01:39,940
那么我们来看看它在运行时看起来是怎么样的

33
00:01:42,290 --> 00:01:44,420
好 我们再来看看这个 xml 文档

34
00:01:44,420 --> 00:01:47,970
看这些值从何而来    

35
00:01:47,970 --> 00:01:50,860
这里我们可以看到 这是根元素  

36
00:01:50,860 --> 00:01:54,020
我们要取出直接嵌套在该元素中的元素 

37
00:01:54,020 --> 00:01:58,110
以及该元素的直属子元素  

38
00:01:58,110 --> 00:02:01,360
ui、ji 和 fm 我们可以看到

39
00:02:01,360 --> 00:02:03,860
它们被提出到这里了 现在 如果我们想要 

40
00:02:03,860 --> 00:02:07,330
提取一篇论文的标题 我们可以看到  

41
00:02:07,330 --> 00:02:11,160
它出现在前页部分的参考书目部分  

42
00:02:11,160 --> 00:02:15,610
我们来看看怎么把它提取出来    

43
00:02:15,610 --> 00:02:19,190
元素树支持基本 XPath 表达式  

44
00:02:19,190 --> 00:02:22,210
因为 在数据整理中 我们通常从一个 XML 文档中拉出大多数数据 

45
00:02:22,210 --> 00:02:25,190
因此这一级别的支持  

46
00:02:25,190 --> 00:02:26,900
足以支持我们的很多需求  

47
00:02:26,900 --> 00:02:29,980
再回到提取标题的问题  

48
00:02:29,980 --> 00:02:32,520
我们可以按如下方式进行 这里 可以看到     

49
00:02:32,520 --> 00:02:34,980
我对根元素使用了 查找 方法  

50
00:02:34,980 --> 00:02:38,160
我使用的是 XPath 表达式

51
00:02:38,160 --> 00:02:41,950
来指定我希望在哪里找到标题元素  

52
00:02:43,000 --> 00:02:45,870
这仅仅表示从当前元素开始 

53
00:02:45,870 --> 00:02:48,920
然后继续操作直至 fm 元素

54
00:02:48,920 --> 00:02:52,580
将其子元素 bibl 或 bibliography (参考书目) 元素   

55
00:02:52,580 --> 00:02:56,070
最后直至标题元素本身    

56
00:02:56,070 --> 00:02:57,630
注意 这与指定 URL 或诸多文件系统中的一条路径  

57
00:02:57,630 --> 00:03:01,280
的方式非常相似  

58
00:03:02,400 --> 00:03:04,190
现在 看起来在该数据中    

59
00:03:04,190 --> 00:03:08,260
很多文本元素实际都包在段落标记中  

60
00:03:08,260 --> 00:03:09,710
我们可以看到 这里实际上是标题的情况  

61
00:03:09,710 --> 00:03:13,230
现在我要做的是

62
00:03:13,230 --> 00:03:16,180
利用我通过该 XPath 表达式得到的标题元素  

63
00:03:16,180 --> 00:03:19,890
我要对标题的所有子元素  

64
00:03:19,890 --> 00:03:22,930
进行循环遍历 这跟我们之前  

65
00:03:22,930 --> 00:03:25,160
遍历根元素的所有子元素的语法 

66
00:03:25,160 --> 00:03:28,400
非常相似 对于每个子元素 我只需取其文本  

67
00:03:28,400 --> 00:03:31,630
然后将其连接至我的标题文本  

68
00:03:31,630 --> 00:03:36,870
现在 我们看到这些元素有两个不同属性

69
00:03:36,870 --> 00:03:39,290
第一个是标签 现在我们看到了文本属性   

70
00:03:39,290 --> 00:03:43,310
元素的很多属性都是很有用的  

71
00:03:43,310 --> 00:03:46,340
大家最后会用到两个最常用的  

72
00:03:46,340 --> 00:03:49,030
这里 我们只需打印出标题  

73
00:03:49,030 --> 00:03:50,900
我们继续 运行它  

74
00:03:50,900 --> 00:03:53,580
然后返回 看看这条代码为我们做了什么   

75
00:03:53,580 --> 00:03:56,770
这里我们可以看到  

76
00:03:56,770 --> 00:04:00,860
标题被实际选中并正确打印了  

77
00:04:00,860 --> 00:04:04,780
这里 我们实际打印出了作者的电子邮件地址  

78
00:04:04,780 --> 00:04:08,110
我们来看看这在代码里是怎么做到的  

79
00:04:08,110 --> 00:04:11,370
这里要使用“查找所有”方法 而不是“查找”

80
00:04:11,370 --> 00:04:14,250
“查找所有”会返回匹配该 XPath 表达式的所有元素  

81
00:04:14,250 --> 00:04:18,350
因此 我们只需循环遍历每个元素    

82
00:04:18,350 --> 00:04:20,870
并且对于每个元素  

83
00:04:20,870 --> 00:04:23,100
我们要进行“查找” 以便定位  

84
00:04:23,100 --> 00:04:25,140
电子邮件标签  那么我们再来一次  

85
00:04:25,140 --> 00:04:29,160
看看该数据 好的 我们的 XPath 表达式  

86
00:04:29,160 --> 00:04:32,260
帮我做到这里 到了这个作者组 

87
00:04:32,260 --> 00:04:34,790
然后对于每位作者 我要“查找”  

88
00:04:34,790 --> 00:04:39,310
Email (电子邮件) 元素 我选定该元素的文本   

89
00:04:39,310 --> 00:04:43,440
这里 然后将其打印出来即可 

90
00:04:43,440 --> 00:04:46,260
那么 再一次通过这种方式 选择了作者组中找到的所有作者  

91
00:04:46,260 --> 00:04:49,190
这是前页部分中  

92
00:04:49,190 --> 00:04:51,351
参考书目部分的一部分  
