1
00:00:00,100 --> 00:00:02,570
那么我们来谈谈我们的程序 我们首先要做的是

2
00:00:02,570 --> 00:00:05,750
创建一个所有承运人值的列表 这个可以手动完成  

3
00:00:05,750 --> 00:00:08,690
可能比研究 HTML 的方法还更简单些    

4
00:00:08,690 --> 00:00:11,760
然后我们需要创建一个机场值的列表   

5
00:00:11,760 --> 00:00:14,820
现在这里有很多值   

6
00:00:14,820 --> 00:00:16,880
我们可能需要做的是编写一个小脚本  

7
00:00:16,880 --> 00:00:18,630
该脚本可以把它们提取出来  

8
00:00:18,630 --> 00:00:22,860
好的 所有页面都将具有这两者的相同列表 

9
00:00:22,860 --> 00:00:25,250
我们可以用浏览器来下载一个示例页面  

10
00:00:25,250 --> 00:00:28,520
从中提取这些值 接下来 我们需要   

11
00:00:28,520 --> 00:00:32,270
发出 HTTP 请求以下载所有数据 我稍后要谈一下     

12
00:00:32,270 --> 00:00:35,460
为什么我们想要立刻下载这些数据     

13
00:00:35,460 --> 00:00:38,415
然后我们要解析数据文件 我们想要这样做的原因是  

14
00:00:38,415 --> 00:00:41,822
在创建解析器时  

15
00:00:41,822 --> 00:00:45,080
我们想要确保使用不会改变的数据

16
00:00:45,080 --> 00:00:47,230
事后 一旦我们进行一些数据清理 

17
00:00:47,230 --> 00:00:50,260
就可以发现我们之所以会得到一些废数据 

18
00:00:50,260 --> 00:00:53,960
是因为解析器中有一个 bug   

19
00:00:53,960 --> 00:00:56,570
如果我们依然拥有用于解析的原始数据 要找出 bug 的位置会容易很多  

20
00:00:56,570 --> 00:00:59,160
我还要指出 

21
00:00:59,160 --> 00:01:02,540
当我们弄清如何解析的时候 一次次重复下载数据真的毫无意义  

22
00:01:02,540 --> 00:01:04,910
你可能需要牢记的是 

23
00:01:04,910 --> 00:01:08,890
对于当年之前的年度 数据不会改变   

24
00:01:08,890 --> 00:01:12,410
所以没有理由多次去检索  

25
00:01:12,410 --> 00:01:15,370
这确实是一种最佳实践 如果你遇到类似这样的情况  

26
00:01:15,370 --> 00:01:17,700
且当你有一个抓取任务时   

27
00:01:17,700 --> 00:01:20,800
通常都会是类似这样的情况 你真的想要  

28
00:01:20,800 --> 00:01:23,720
首先抓取需要的所有数据 然后通过单独的程序

29
00:01:23,720 --> 00:01:28,580
进行抓取 因此 对于这个问题   

30
00:01:28,580 --> 00:01:31,830
我们的解决方法基本上分三步 首先需要创建用来发出 HTTP 请求时 

31
00:01:31,830 --> 00:01:34,680
将用到的所有值 然后需要 

32
00:01:34,680 --> 00:01:37,570
发出所有 HTTP 请求 并下载所需的数据  

33
00:01:37,570 --> 00:01:40,750
最后 我们要解析这些数据文件中需要的数据 

34
00:01:40,750 --> 00:01:44,400
将其打造为特定的数据块 

35
00:01:44,400 --> 00:01:46,660
即我们想要使用的具体项目   
