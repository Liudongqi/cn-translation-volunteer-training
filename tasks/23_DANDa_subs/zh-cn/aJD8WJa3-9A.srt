1
00:00:00,110 --> 00:00:03,380
好 我们来开始实际解决这个问题

2
00:00:03,380 --> 00:00:05,450
我们要记得 我们程序的第一步是  

3
00:00:05,450 --> 00:00:08,860
从一个示例页面提取承运人的完整列表  

4
00:00:08,860 --> 00:00:12,860
和机场的完整列表 所以 我在这里做的是  

5
00:00:12,860 --> 00:00:16,490
下载本页面 然后我要开始解析该页面  

6
00:00:16,490 --> 00:00:18,890
以便取得这两张列表  

7
00:00:18,890 --> 00:00:21,130
让我们来看一些代码 我用来解析 HTML 的是 

8
00:00:21,130 --> 00:00:23,410
BeautifulSoup

9
00:00:23,410 --> 00:00:25,860
更具体地说 是 BeautifulSoup 4

10
00:00:25,860 --> 00:00:28,740
有很多文件包管理软件 大家可以任选其一来下载 BeautifulSoup  

11
00:00:28,740 --> 00:00:30,940
并将其安装到本地

12
00:00:30,940 --> 00:00:33,470
我个人喜欢用 PIP 如果你还没有安装 BeautifulSoup

13
00:00:33,470 --> 00:00:35,410
可以用 Google 搜索安装说明 

14
00:00:35,410 --> 00:00:38,490
BeautifulSoup 能让我们 

15
00:00:38,490 --> 00:00:41,450
解析文档树 

16
00:00:41,450 --> 00:00:45,440
就本例来说 是解析 HTML 文档设树 

17
00:00:45,440 --> 00:00:48,540
这与解析 XML 的基本方法类似 好 我来向大家展示  

18
00:00:48,540 --> 00:00:50,860
该代码是如何工作的 我所做的是  

19
00:00:50,860 --> 00:00:53,310
完成了对其的配置 以便由选项功能 

20
00:00:53,310 --> 00:00:55,220
来进行大部分的工作 我要调用选项 

21
00:00:55,220 --> 00:00:57,830
注意 我用来调用的是  

22
00:00:57,830 --> 00:01:01,170
soup 值 而 soup 则是

23
00:01:01,170 --> 00:01:04,540
我在本地文件调用 beautiful soup 后 作为响应而得到的  

24
00:01:04,540 --> 00:01:07,400
该本地文件是这份文件的一个保存副本  

25
00:01:07,400 --> 00:01:11,540
另外 我要传递这个字符串 CarrierList

26
00:01:12,570 --> 00:01:15,970
BeautifulSoup 传递给我的是  

27
00:01:15,970 --> 00:01:19,390
这份 HTML 文档的顶级元素 然后我能做的是

28
00:01:19,390 --> 00:01:21,970
使用这里的 查找 方法  

29
00:01:21,970 --> 00:01:23,830
其意思是帮我查找到   

30
00:01:23,830 --> 00:01:27,580
文档树中的第一个后代元素  

31
00:01:27,580 --> 00:01:32,560
在该文档树上 元素的 ID 属性为 CarrierList 对吗？ 

32
00:01:32,560 --> 00:01:34,830
那我们来研究这个 HTML 知道我们  

33
00:01:34,830 --> 00:01:37,040
为何要以这种方式编写它吗？这一次  

34
00:01:37,040 --> 00:01:40,790
我还是可以使用 Google Chrome 的检查元素功能来找到该 HTML

35
00:01:40,790 --> 00:01:46,060
这是 CarrierList 注意 该元素的 ID 属性是

36
00:01:46,060 --> 00:01:51,540
CarrierList

37
00:01:51,540 --> 00:01:55,850
是 CarrierList 然后 我们将刚才研究的 HTML 元素作为其值  

38
00:01:55,850 --> 00:02:00,352
然后 针对 CarrierList 我要调用 查找所有   

39
00:02:00,352 --> 00:02:03,464
查找所有与查找非常相似   

40
00:02:03,464 --> 00:02:06,790
它会找出选项标签   

41
00:02:06,790 --> 00:02:10,729
或选项元素等后代 不过与查找不同的是   

42
00:02:10,729 --> 00:02:13,400
查找所有实际会找到所有句子  

43
00:02:13,400 --> 00:02:16,610
而并非只是第一个  

44
00:02:16,610 --> 00:02:18,760
好 这里将会发生的情况是 我将只能循环访问它们  

45
00:02:18,760 --> 00:02:21,520
而我只能构建一个所有值的列表  

46
00:02:21,520 --> 00:02:24,360
这里我实际做的是  

47
00:02:24,360 --> 00:02:28,900
按顺序找到它们中的每一个  

48
00:02:28,900 --> 00:02:33,100
并且将拉取其值属性的值  

49
00:02:33,100 --> 00:02:36,960
因此 这是我在随后任何有关（比如说）

50
00:02:36,960 --> 00:02:42,070
AirTran 航空或阿拉斯加航空公司的 http 数据请求中需要传递的值     

51
00:02:42,070 --> 00:02:44,730
这就是如何获得我们需要的承运人的方法 我采用的是  

52
00:02:44,730 --> 00:02:47,140
一种非常类似的过程 事实上 就是与获取航空公司完整列表   

53
00:02:47,140 --> 00:02:48,760
相同的过程
